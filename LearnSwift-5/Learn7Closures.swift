//
//  Learn7Closures.swift
//  LearnSwift-5
//
//  Created by 祁子栋 on 2020/4/17.
//  Copyright © 2020 祁子栋. All rights reserved.
//

import Foundation

/**
 闭包
 
 闭包是可以在你的代码中被传递和引用的功能性独立代码块。
 Swift 中的闭包和 C  以及 Objective-C 中的 blocks 很像，还有其他语言中的匿名函数也类似。

 闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的闭合并包裹那些常量和变量，因此被称为“闭包”，Swift 能够为你处理所有关于捕获的内存管理的操作。
 
 
 在函数章节中有介绍的全局和内嵌函数，实际上是特殊的闭包。闭包符合如下三种形式中的一种：

 全局函数是一个有名字但不会捕获任何值的闭包；   ------------
 内嵌函数是一个有名字且能从其上层函数捕获值的闭包；
 闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包。
 
 
 Swift 的闭包表达式拥有简洁的风格，鼓励在常见场景中实现简洁，无累赘的语法。常见的优化包括：

 利用上下文推断形式参数和返回值的类型；
 单表达式的闭包可以隐式返回；
 简写实际参数名；
 尾随闭包语法。
 
 
 */


func useClosures() {
    
    //闭包表达式
    
    /*
     
     内嵌函数，在内嵌函数中有介绍，一种在较复杂的函数中方便命名和定义独立代码块的手段。总之，有时候对于写更简短的没有完整定义和命名的类函数构造非常有用，尤其是在你处理一些函数时调用其他函数作为该函数的参数时。

     闭包表达式是一种在简短行内就能写完闭包的语法。闭包表达式为了缩减书写长度又不失易读明晰而提供了一系列的语法优化。下边的闭包表达式栗子通过使用几次迭代展示 sorted(by:)方法的精简来展示这些优化，每一次都让相同的功能性更加简明扼要。
     
     */
    
    let names = ["Chris","Alex","Ewa","Barry","Daniella"]
    var reversedNames = names.sorted(by: backward(_:_:));
    print(names, reversedNames)
    
    /*
     这个时候就可以完成数组的倒序排序。
     但是，实际只是用了s1 > s2， 完全的写一个方法有点麻烦
     
     完全可以简化成使用内部闭包
     
     */
    
    
    
    
    
    //============================================================
//   MARK: 闭包表达式语法
    /*
     闭包表达式语法有如下的一般形式：

       { (parameters) -> (return type) in
         statements
       }
     
     闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。
     可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。
     
     */
    
    //下面这个栗子展示一个之前 backward(_:_:) 函数的闭包表达版本：
    reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
        return s1 < s2
    })
    print(reversedNames)
    
    /*
     需要注意的是行内闭包的形式参数类型和返回类型的声明与 backwards(_:_:) 函数的申明相同。
     在这两个方式中，都书写成 (s1: String, s2: String) -> Bool。
     总之对于行内闭包表达式来说，形式参数类型和返回类型都应写在花括号内而不是花括号外面。

     闭包的函数整体部分由关键字 in 导入，
     这个关键字表示闭包的形式参数类型和返回类型定义已经完成，并且闭包的函数体即将开始。
     
     */
    
    
    //闭包的函数体特别短以至于能够只用一行来书写：
    reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
    
    
    
    //============================================================
    //MARK: 从语境中推断类型
    
    /*
     由于排序闭包为实际参数来传递给方法，Swift 就能推断它的形式参数类型和返回类型。
     sorted(by:) 方法是在字符串数组上调用的，所以它的形式参数必须是一个 (String, String) -> Bool 类型的函数。
     这意味着 (String, String)和 Bool 类型不需要写成闭包表达式定义中的一部分。
     因为所有的类型都能被推断，返回箭头 ( ->) 和围绕在形式参数名周围的括号也能被省略
     
     最终可以简写为
     */
    reversedNames = names.sorted(by: {s1, s2 in return s1 < s2})
    
    
    //MARK: 从单表达式闭包隐式返回
    //单表达式闭包能够通过从它们的声明中删掉 return 关键字来隐式返回它们单个表达式的结果，前面的栗子可以写作
    reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
    
    
    
    //MARK: 简写的实际参数名
    /*
     Swift 自动对行内闭包提供简写实际参数名，你也可以通过 $0 , $1 , $2 等名字来引用闭包的实际参数值。
     */
    reversedNames = names.sorted(by: { $0 > $1 } )
    
    
    
    
    
    //============================================================
    
    
    
    //============================================================
    
}

func backward(_ s1:String, _ s2:String) ->Bool {
    return s1 > s2
}







